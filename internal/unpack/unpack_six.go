/*
 * MIT License
 *
 * Copyright (c) 2024 The autotiler authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package unpack

import (
	"image"
)

const (
	sixPackType = 6
)

// From6to16Terrain1 generates a 16x1 tileset image from a 2x3 tileset using terrain 1 pattern.
// It uses the exported 6x6 to 28 tileset and appends specific tiles to create the terrain 1 pattern.
//
// Parameters:
//
//	none
//
// Returns:
//
//	*image.NRGBA - a pointer to the generated image
//	error - an error if the pack type is invalid
func (u *Unpacker) From6to16Terrain1() (*image.NRGBA, error) {
	exp := export6to28TileSet()

	// Create the quadMap for terrain 1 pattern
	// Append specific tiles to create the terrain 1 pattern
	quadMap := append(exp[:14], exp[15], exp[14]) // 15 - filled terrain 2, 14 - small terrain 1 patch on top
	return u.from6to16Terrain(quadMap)
}

// From6to16Terrain2 generates a 16x1 image from a 2x3 tileset using terrain 2 pattern.
// It uses the exported 6x6 tileset and appends specific tiles to create the terrain 2 pattern.
//
// Parameters:
//
//	none
//
// Returns:
//
//	*image.NRGBA - a pointer to the generated image
//	error - an error if the pack type is invalid
func (u *Unpacker) From6to16Terrain2() (*image.NRGBA, error) {
	exp := export6to28TileSet()

	// Create the quadMap for terrain 2 pattern
	// Append specific tiles to create the terrain 2 pattern
	quadMap := append(exp[14:], exp[1], exp[0]) // 0 - filled terrain 1, 1 - small terrain 2 patch on top

	// Generate the 16x1 image using the terrain 2 pattern
	return u.from6to16Terrain(quadMap)
}

// From6to28 generates a 14x2 canvas with 28 tiles from a 2x3 tileset.
// It uses the quadMap generated by the export6to28TileSet function to draw each tile.
//
// Parameters:
//
//	none
//
// Returns:
//
//	*image.NRGBA - a pointer to the generated image
//	error - an error if the pack type is invalid
func (u *Unpacker) From6to28() (*image.NRGBA, error) {
	if u.xTiles*u.yTiles != sixPackType {
		return nil, errInvalidPackType
	}
	canvas := image.NewNRGBA(image.Rect(0, 0, u.tileWidth*14, u.tileHeight*2))
	// todo optimize to generate automatically and consider scaling for 47 and 255 tilesets

	quadMap := export6to28TileSet()

	for idx := 0; idx < 28; idx++ {
		u.drawFullTile(canvas, quadMap[idx], idx, 14)
	}
	return canvas, nil
}

// From6to48Terrain1 generates a 12x4 tile set image from a 2x3 tile set using terrain 1 pattern.
// It uses the provided quadMap to determine the tile pattern for each tile.
//
// Parameters:
//
//	none
//
// Returns:
//
//	*image.NRGBA - a pointer to the generated image
//	error - an error if the pack type is invalid
func (u *Unpacker) From6to48Terrain1() (*image.NRGBA, error) {
	quadMap := export6to28TileSet()
	quads := [16]quadTileData{
		quadMap[1],
		quadMap[4],
		&[4][2]int{
			{3, 1}, {2, 1},
			{3, 0}, {2, 0},
		},
		quadMap[2],
		quadMap[5],
		quadMap[9],
		&[4][2]int{
			{0, 0}, {0, 5},
			{3, 2}, {0, 2},
		},
		quadMap[13],
		&[4][2]int{
			{1, 5}, {2, 5},
			{3, 2}, {1, 1},
		},
		&[4][2]int{
			{1, 5}, {2, 5},
			{0, 1}, {0, 2},
		},
		quadMap[3],
		&[4][2]int{
			{3, 5}, {0, 5},
			{0, 1}, {1, 1},
		},
		quadMap[8],
		quadMap[0],
		quadMap[14],
		quadMap[12],
	}

	return u.from6to48Terrain(quads)
}

// From6to48Terrain2 generates a 12x4 tile set image from a 2x3 tile set using terrain 2 pattern.
// It draws the 48 tiles on the canvas using the quadMap to determine the tile pattern for each tile.
//
// Parameters:
//
//	None
//
// Returns:
//
//	*image.NRGBA - a pointer to the generated image
//	error - an error if the pack type is invalid
func (u *Unpacker) From6to48Terrain2() (*image.NRGBA, error) {
	quadMap := export6to28TileSet()
	offset := 14 // terrain 2 starts from 14th index, so we need to offset it
	quads := [16]quadTileData{
		quadMap[offset+1],
		quadMap[offset+4],
		&[4][2]int{
			{0, 2}, {3, 2},
			{0, 5}, {3, 5},
		},
		quadMap[offset+2],
		quadMap[offset+5],
		quadMap[offset+9],
		// 2nd 16
		&[4][2]int{
			{1, 3}, {3, 0},
			{2, 1}, {3, 1},
		},
		quadMap[offset+13],
		&[4][2]int{
			{1, 2}, {2, 2},
			{2, 1}, {2, 4},
		},
		&[4][2]int{
			{1, 2}, {2, 2},
			{1, 4}, {3, 1},
		},
		// 3rd 16
		quadMap[offset+3],
		&[4][2]int{
			{2, 0}, {3, 0},
			{1, 4}, {2, 4},
		},
		quadMap[offset+8],
		quadMap[offset],
		quadMap[0], // terrain 1
		quadMap[offset+12],
	}

	return u.from6to48Terrain(quads)
}

// from6to16Terrain generates a 16x1 image from a 6x6 tileset using the provided quadMap.
// It draws the 16 tiles on the canvas using the quadMap to determine the tile pattern for each tile.
//
// Parameters:
//
//	quadMap - a slice of quadTileData representing the tile patterns for each tile
//
// Returns:
//
//	*image.NRGBA - a pointer to the generated image
//	error - an error if the pack type is invalid
func (u *Unpacker) from6to16Terrain(quadMap []quadTileData) (*image.NRGBA, error) {
	if u.xTiles*u.yTiles != sixPackType {
		return nil, errInvalidPackType
	}
	canvas := image.NewNRGBA(image.Rect(0, 0, u.tileWidth*16, u.tileHeight*1))
	// todo optimize to generate automatically and consider scaling for 47 and 255 tilesets

	for idx := 0; idx < 16; idx++ {
		u.drawFullTile(canvas, quadMap[idx], idx, 16)
	}
	return canvas, nil
}

// from6to48Terrain generates a 12x4 tile set from a 2x3 tile set.
//
// Parameters:
//
//	quadMap [16]quadTileData - an array of quadTileData representing the tile patterns for each new tile produced
//	from the original 2x3 tile set required to build 12x4 tile set
//
// Returns:
//
//	*image.NRGBA - a pointer to a new image.NRGBA representing the 12x4 tile set built from the original 2x3 tile set
//	error - an error if any occurred during the process
func (u *Unpacker) from6to48Terrain(quadMap [16]quadTileData) (*image.NRGBA, error) {
	if u.xTiles*u.yTiles != sixPackType {
		return nil, errInvalidPackType
	}

	// todo pass list of tile patterns so it would be reusing code for terrain 2
	canvas := image.NewNRGBA(image.Rect(0, 0, u.tileWidth*12, u.tileHeight*4))
	tileset := newTileSet(canvas, u.tileWidth, u.tileHeight)

	tilePattern := quadMap[0]
	tile := image.NewNRGBA(image.Rect(0, 0, u.tileWidth, u.tileHeight))
	// fully drawn
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(0, 2, tile)
	tile = tileset.setTileWithRotationLeft(3, 3, tile)
	tile = tileset.setTileWithRotationLeft(0, 0, tile)
	tile = tileset.setTileWithRotationLeft(1, 3, tile)

	tilePattern = quadMap[1]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(0, 1, tile)
	tileset.setTileWithRotationLeft(2, 3, tile)

	tilePattern = quadMap[2]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(0, 3, tile)

	tilePattern = quadMap[3]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(1, 2, tile)
	tile = tileset.setTileWithRotationLeft(3, 2, tile)
	tile = tileset.setTileWithRotationLeft(3, 0, tile)
	tile = tileset.setTileWithRotationLeft(1, 0, tile)

	tilePattern = quadMap[4]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(1, 1, tile)
	tile = tileset.setTileWithRotationLeft(2, 2, tile)
	tile = tileset.setTileWithRotationLeft(3, 1, tile)
	tile = tileset.setTileWithRotationLeft(2, 0, tile)

	tilePattern = quadMap[5]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(2, 1, tile)

	// 2nd 16
	tilePattern = quadMap[6]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(4, 0, tile)
	tile = tileset.setTileWithRotationLeft(4, 3, tile)
	tile = tileset.setTileWithRotationLeft(7, 3, tile)
	tile = tileset.setTileWithRotationLeft(7, 0, tile)

	tilePattern = quadMap[7]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(5, 1, tile)
	tile = tileset.setTileWithRotationLeft(5, 2, tile)
	tile = tileset.setTileWithRotationLeft(6, 2, tile)
	tile = tileset.setTileWithRotationLeft(6, 1, tile)

	tilePattern = quadMap[8]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(5, 0, tile)
	tile = tileset.setTileWithRotationLeft(4, 2, tile)
	tile = tileset.setTileWithRotationLeft(6, 3, tile)
	tile = tileset.setTileWithRotationLeft(7, 1, tile)

	tilePattern = quadMap[9]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(6, 0, tile)
	tile = tileset.setTileWithRotationLeft(4, 1, tile)
	tile = tileset.setTileWithRotationLeft(5, 3, tile)
	tile = tileset.setTileWithRotationLeft(7, 2, tile)

	// 3rd 16
	tilePattern = quadMap[10]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(8, 3, tile)
	tile = tileset.setTileWithRotationLeft(11, 3, tile)
	tile = tileset.setTileWithRotationLeft(11, 0, tile)
	tile = tileset.setTileWithRotationLeft(8, 0, tile)

	tilePattern = quadMap[11]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(9, 0, tile)
	tile = tileset.setTileWithRotationLeft(8, 2, tile)
	tile = tileset.setTileWithRotationLeft(10, 3, tile)
	tile = tileset.setTileWithRotationLeft(11, 2, tile)

	tilePattern = quadMap[12]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(8, 1, tile)
	tile = tileset.setTileWithRotationLeft(9, 3, tile)
	tile = tileset.setTileWithRotationLeft(11, 1, tile)
	tile = tileset.setTileWithRotationLeft(10, 0, tile)

	tilePattern = quadMap[13]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(10, 1, tile)

	tilePattern = quadMap[14]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(9, 2, tile)

	tilePattern = quadMap[15]
	u.drawFullSingleTile(tile, tilePattern)
	tileset.setTile(9, 1, tile)
	_ = tileset.setTileWithRotationLeft(10, 2, tile)

	return tileset.getCanvas(), nil
}

// export6to28TileSet generates a quad from a 2x3 tile set sufficient to build 2 16 tiles tile sets
// for both terrains present in the original 2x3 tile set
//
// Returns:
//
//	[28]quadTileData - an array of quadTileData representing the tile patterns for each new tile produced
//	from the original 2x3 tile set required to build 14x2 tile set
func export6to28TileSet() [28]quadTileData {
	return [28]quadTileData{
		// terrain 1
		{
			{1, 3}, {2, 3}, // tile 1
			{1, 4}, {2, 4},
		},
		{
			{3, 0}, {2, 0}, // tile 2
			{1, 4}, {2, 4},
		},
		{
			{3, 3}, {0, 5}, // tile 3
			{3, 0}, {2, 2},
		},
		{
			{3, 3}, {0, 0}, // tile 4
			{3, 0}, {2, 2},
		},
		{
			{3, 3}, {0, 3}, // tile 5
			{3, 4}, {0, 4},
		},
		{
			{3, 3}, {0, 5}, // tile 6
			{3, 4}, {0, 2},
		},
		{
			{3, 3}, {0, 0}, // tile 7
			{3, 4}, {0, 2},
		},
		{
			{3, 3}, {0, 5}, // tile 8
			{3, 4}, {1, 1},
		},
		{
			{3, 3}, {0, 0}, // tile 9
			{3, 4}, {1, 1},
		},
		{
			{3, 5}, {0, 5}, // tile 10
			{3, 2}, {0, 2},
		},
		{
			{3, 5}, {1, 0}, // tile 11
			{3, 2}, {0, 2},
		},
		{
			{3, 5}, {1, 0}, // tile 12
			{3, 2}, {1, 1},
		},
		{
			{3, 5}, {1, 0}, // tile 13
			{0, 1}, {0, 2},
		},
		{
			{3, 5}, {1, 0}, // tile 14
			{1, 0}, {1, 1},
		},
		// end of terrain 1
		// terrain 2
		{
			{0, 0}, {1, 0}, // tile 15
			{0, 1}, {1, 1},
		},
		{
			{0, 5}, {3, 5}, // tile 16
			{0, 1}, {1, 1},
		},
		{
			{0, 4}, {3, 0}, // tile 17
			{0, 5}, {1, 5},
		},
		{
			{0, 4}, {1, 4}, // tile 18
			{0, 5}, {1, 5},
		},
		{
			{0, 3}, {3, 3}, // tile 19
			{0, 4}, {3, 4},
		},
		{
			{0, 3}, {3, 0}, // tile 20
			{0, 4}, {3, 1},
		},
		{
			{0, 3}, {2, 3}, // tile 21
			{0, 4}, {3, 1},
		},
		{
			{0, 3}, {3, 0}, // tile 22
			{0, 4}, {2, 4},
		},
		{
			{0, 3}, {2, 3}, // tile 23
			{0, 4}, {2, 4},
		},
		{
			{2, 0}, {3, 0}, // tile 24
			{2, 1}, {3, 1},
		},
		{
			{2, 0}, {2, 3}, // tile 25
			{2, 1}, {3, 1},
		},
		{
			{2, 0}, {2, 3}, // tile 26
			{2, 1}, {2, 4},
		},
		{
			{2, 0}, {2, 3}, // tile 27
			{1, 4}, {3, 1},
		},
		{
			{2, 0}, {2, 3}, // tile 28
			{1, 4}, {2, 4},
		},
	}
}
